## 콘텍스트 API로 데이터 전달하기

상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 때 속성값을 사용한다.

가까운 거리면 충분하지만 많은 수의 하위 컴포넌트가 있다면 컴포넌트를 내려주는 코드를 반복적으로 작성해줘야 한다.

중간에 있는 컴포넌트들은 자신은 사용하지 않으면서 내려주는 코드를 써줘야함

이 때 콘택스트 API를 사용하면 간단하게 처리할 수 있다.

createContext 함수를 가져오고 초기값을 넣어서 호출하면 객체가 반환된다.

그 객체에는 Provider와 Consumer 컴포넌트가 들어 있다.

Provider에서 value에 값을 넣어주면 Consumer에서 그 값을 받아서 처리할 수 있다.

```jsx
import React, { createContext } from 'react';

const UserContext = createContext('unknown');

<UserContext.Provider value="mike">
<UserContext.Provider />

...

<UserContext.Consumer>
	{username => <p>{`${username}님 안녕하세요`}</p>}
</UserContext.Consumer>
```

<UserContext.Consumer> → render props라는 패턴으로 작성된 코드
children을 함수 형태로 작성한다. 실제로 컨슈머 컴포넌트를 구현할 때 이 children 함수를 호출하는 방식으로 작성한다.

아래와 같이 Consumer가 사용됐을 때 필요한 값을 찾기 위해 부모로 올라가면서 가장 가까운 Provider를 찾게 된다.

만약 root까지 올라가도 찾지 못하면 처음에 정의된 기본값을 사용한다.

초기값이 있으므로 테스트 코드 작성하기 편리하다.

Provider 컴포넌트의 value가 변경되면 하위의 모든 Consumer 컴포넌트는 다시 렌더링이 된다.

여기서 중요한 점은 중간에 위치한 컴포넌트가 렌더링되지 않더라도 이 값이 변경 됐을 때는 이 value값이 변경됐을 때는 Consumer 컴포넌트가 재렌더링 된다는 점이다.

value를 useState를 사용해 상태값으로 관리해도 된다.

```jsx
const [name, setName] = useState('mike');

...

<UserContext.Provider value={name}>
```

중간에 있는 컴포넌트가 렌더링 되지 않아도 Consumer 컴포넌트는 value가 바뀌므로 재렌더링된다.

hook을 이용하면 좀 더 간편하게 작성이 가능하다.

```jsx
const username = useContext(UserContext);
<UserContext.Consumer>
    {<p>{`${username}님 안녕하세요`}</p>}
</UserContext.Consumer>;
```

Context를 여러 개를 사용할 수도 있다.

데이터의 종류별로 context를 나누는 것에는 성능상 이점이 있다.

해당하는 데이터가 변경될 때 필요한 부분만 렌더링이 되기 때문이다.

하위 컴포넌트에서 데이터를 수정하고 싶을 때는 데이터를 수정할 수 있는 함수를 별도의 Context로 분리해낼 수 있다.

```jsx
const userContext = createContext({ username: 'unknown' });
const SetUserContext = createContext(() => {});

...

const [user, setUser] = useState({ username: 'unknown' });
<SetUserContext.Provider value={setUser}>
	<UserContext.Provider value={user}>
		...
	</UserContext.Provider value={user}>
</SetUserContext.Provider value={setUser}>

```

child에서는 setUser = useContext(SetUserContext) 만들어서 수정할 수 있음

여러 데이터를 관리하고 싶을 때는 useState보다 리듀서를 사용하는게 좋음

Context를 사용할 때 주의할 점

지금처럼 프로바이더 value에 직접 입력을 하면 이 컴포넌트가 렌더링이 될 때마다 새로운 객체가 만들어진다. 따라서 이 내부 값이 바뀌지 않아도 Consumer에서 계속 렌더링 된다.
