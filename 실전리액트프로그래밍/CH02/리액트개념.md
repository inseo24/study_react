리액트는 바닐라JS와 달리 비즈니스 로직과 UI 코드가 분리되어 있다.
UI 코드를 JSX로 나타내고 어떻게 변할 지 코드로 바로 확인이 가능함.
선언형 프로그래밍으로 추상화 단계가 명령형 보다 높음

### 컴포넌트의 속성값과 상태값

리액트 컴포넌트에서 UI 데이터를 속성값이나 상태값으로 관리한다.

변경사항을 상태값으로 관리해야 한다.

→ **useState** 사용

부모컴포넌트가 렌더링될 때 자식 컴포넌트도 같이 렌더링되어서 상태값, 속성값을 갱신

이 때 자식의 속성값이 변하지 않았을 경우 자식 컴포넌트의 렌더링이 필요하지 않을 경우도 있음

→ React.memo를 사용해서 속성값이 변경될 때만 자식 컴포넌트를 렌더링할 수도 있음

속성값은 불변변수, 상태값은 불변변수가 아님.

하지만 상태값도 불변변수로 관리하는게 좋음

상태값 변경유무를 이전값과의 차이로 확인하므로 내부의 속성값만 변경되고 상태값이 변경되지 않으면 리액트에서 변경을 인지하지 못함

→ 그래서 상태값도 불변변수로 관리하는게 좋음

코드의 복잡도도 낮아짐

불변변수로 관리하는 방법 중 하나는 전개연산자(..., spread operator) 사용

### 컴포넌트 함수의 반환값

1. 리액트 element
2. 컴포넌트
3. 단순 문자열, 숫자, 배열(값, element 둘다 가능)(배열 반환 시 리액트 요소는 key가 필요), null, Boolean 값
4. Fragment - 이 때는 key가 필요하지 않음, 순서가 key 역할을 함. <></> 이런 식으로 사용 가능
5. 리액트 Portal - react-dom의 createPortal을 사용해 리액트 element를 작성할 수 있음, 보통 모달을 위해서 사용되는 경우가 있음

### 리액트 요소와 가상돔1

react element : type, props, ..., 불변 객체여서 변경 시 에러 발생

리액트는 렌더링 성능을 위해 가상돔을 이용.

돔 변경 최소화를 위함 - 메모리에 가상돔을 올리고 변경 전후를 비교해 변경된 부분만 반영한다.

```jsx
const jsxDOM = (
    <a key="key1" style={{ width: 100 }} href="http://google.com">
        click here
    </a>
);

console.log(jsxDOM);
const consoleLogResult = {
    type: "a",
    key: "key1",
    ref: null,
    props: {
        href: "http://google.com",
        style: {
            width: 100,
        },
        children: "click here",
    },
    // ...
};
```

DOM element의 key가 변경될 때 리액트 DOM에서 element가 삭제됐다가 추가되는데,

그 때마다 리액트가 이전 것을 삭제하고 다시 만드는 작업이 내부적으로 이뤄진다.

컴포넌트 안에 key를 넣을 경우 컴포넌트 key가 변경되게 될 때마다 해당 컴포넌트가 삭제됐다가 다시 추가된다. 삭제되는 걸 unmount, 추가되는 걸 mount라고 한다.

새로 mount될 때마다 useState에서 초기화가 이뤄진다.

비슷하게 조건부 렌더링의 경우에도 비슷하게 mount - unmount가 반복된다.

React element tree

jsx → react element tree로 구성이 된다.

데이터 변경에 의한 화면 업데이트는 렌더 단계와 커밋 단계를 거친다.

렌더 단계는 실제 돔에 반영할 변경사항을 파악하는 단계이고, 이를 위해 가상 돔을 이용한다. 가상 돔은 react element로부터 만들어지고 리액트는 렌더링을 할 때마다 가상 돔을 만들고 이전의 가상 돔과 비교를 한다.

커밋 단계는 파악된 변경 사항을 실제 돔에 반영하는 단계이다. 필요한 돔만 변경할 수 있도록 리액트가 내부적으로 처리를 해준다.

### 흐름

리액트 요소 트리가 실제 돔으로 만들어 지기 위해서는 모든 리액트 요소의 타입 속성값이 문자열이어야 한다. 예를 들어, type이 Title 인 리액트 요소 트리가 있다면 한번 더 변환될 필요가 있다.

한번 더 변환하여 아래와 같이 모든 리액트 요소 타입의 속성값이 문자열이 된다면 이것을 가상 돔이라고 할 수 있다. 하지만, 가상 돔은 UI 에서 변경된 부분을 빨리 찾기 위한 개념이므로, 이러한 컴포넌트의 리액트 요소도 가상돔의 일부라고 생각할 수 있다.

최종 리액트 요소 트리를 만들기 위해서 치환되는 Title과 같은 컴포넌트의 리액트 요소도 메모리에 저장되서 렌더 단계의 효율을 높이는데 사용됩니다. 렌더 단계는 render 함수를 호출하거나 상태값 변경 함수를 호출하는 것으로 시작될 수 있습니다.

렌더 함수가 호출되면서  최초의 렌더 단계가 실행이 되었고, 이렇게 만들어진 가상 돔이 실제 돔으로 만들어진다. 사용자의 행위로 컴포넌트의 상태값이 변경이 되었고, 곧 두번째 랜더 단계가 실행이 되고, 새로운 가상 돔이 만들어진다. 이 때, 이전의 가상 돔과 비교해서 변경된 부분만 실제 돔에 반영된다.

### 리액트 Hook

-   컴포넌트에 기능을 추가할 때 사용하는 함수
-   ex) 컴포넌트에 상태값 추가, 자식 요소에 접근 등
-   리액트 16.8에 새로 추가됨
-   useState : 상태값 추가
    -   비동기면서 batch로 처리됨
    -   여러 개의 상태값 요청은 batch로 처리됨
    -   상태값 변경 함수를 왜 비동기+배치로 처리할까?
        -   이걸 동기로 처리하면 하나의 상태값 변경 함수가 호출될 때마다 화면을 다시 그리는 비효율성
        -   변경은 동기로 처리하고 매번 화면을 다시 그리지 않으면 UI 데이터와 화면간에 불일치가 발생해서 문제
        -   초기값이 객체여도 동일
        -   해결하고 싶으면 함수를 입력하면 됨
-   useEffect : 부수효과(외부 상태의 변경) 처리
    -   서버 API 호출, 이벤트 핸들러 등록 등
    -   특별한 이유가 없다면 모든 부수 효과는 uesEffect 훅에서 처리하는 게 좋다.
    -   렌더링 중에 부수 효과가 발생하면 프로그램 복잡도가 크게 증가한다. 유닛테스트도 힘들고 순수 함수의 장점이 없어짐. 대부분 렌더링 후에 부수 효과가 처리하는게 좋다.
    -   첫 번째 매개변수로 함수를 입력하면 이 함수는 컴포넌트가 렌더링된 후에 호출된다.
    -   정확히 말하면, 렌더링 결과가 실제 돔에 반영되고 비동기로 호출된다.
    -   첫 번째 매개변수 함수를 부수효과 함수라 한다.

### useEffect

-   두 번째 매개변수로 **의존성 배열**을 넣어 그 배열 안의 값이 변경될 때만 부수 효과 함수가 실행되게 처리 할 수 있음, 만약 비워두게 되면 마운트된 이후 한 번만 실행되고 그 이후로 실행되지 않음
-   의존성 배열
    -   부수효과 함수에서 사용한 변수 등을 잘 봐야 한다(값이 변하는 것들)
    -   컴포넌트의 상태값이나 속성값, 또는 이 컴포넌트 내부에서 정의된 지역 변수나 지역 함수 같은 것들
    -   상태값 변경 함수(set~)는 값이 변경되지 않는다는 것이 보장되므로 예외적으로 의존성 배열에 입력하지 않음
    -   꼭 필요한 경우에만 입력하는게 좋다.

### 리액트 Custom Hook

```jsx
export default function useUser(userId) {
	const [user, setUser] = useState(null);
	userEffect(() ⇒ {
	getUserApi(userId).then(data ⇒ setUser(data));
	}, [userid]);
	return user;

}
```

이렇게 export하고 받는 곳에서 import한 다음 변수에 저장하는 식 등으로 사용 가능

```jsx
const user = useUser(userId);
```

mount 여부를 알려주는 custom hook을 만든다면

```jsx
export default function useMount() {
    const [mounted, setMounted] = useState(false);
    useEffect(() => {
        setMounted(true);
    }, []);
    return mounted;
}
```

로그인만된 사용자만 이용가능한 페이지라면 useBlockIfNoLogin() 이런 훅을 만드는 등

어던 페이지에서 사용자가 작성한 내용이 있다고 할 때 저장하지 않고 다른 페이지로 나가려고 할 때 저장되지 않았는데 나가려고 할 때 나가시겠습니까? 하는 alert 을 띄워주는 useBlockUnsavedChange(desc) 이런 것도 쓸 수 있고...

사용하려면 여러 분야로 활용이 가능하다.

### 훅 사용 시 지켜야 할 규칙

1. 하나의 컴포넌트에서 훅을 호출하는 순서는 항상 같아야 한다.
    1. if문이나 for문 안에서 hook을 사용 하면 안됨
    2. 함수 안에서 hook을 호출하면 안됨(이 함수가 항상 호출된다는 보장이 없음)
    3. if문과 return 문 사이에 hook을 작성하지 않음, if문을 사용한다면 hook을 먼저 쓰고 그 다음 if문 그 다음 return 문 사용
    4. 순서 정보가 중요함
2. 훅은 함수형 컴포넌트 또는 커스텀 훅 안에서만 호출되어야 한다.
